# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Meff
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtCore import QCoreApplication
from qgis.core import QgsProcessing, QgsProcessingAlgorithm, QgsProcessingException, QgsProcessingParameterFeatureSource, QgsProcessingParameterExpression, QgsProcessingParameterFeatureSink, QgsProcessingProvider, QgsProcessingParameterMultipleLayers, QgsProcessingUtils

from ..shared import utils, qgsTreatments
from ..steps import params

class MeffAlgorithmsProvider(QgsProcessingProvider):

    def __init__(self):
        self.alglist = [LanduseAlgorithm(), ApplyFragmentationAlgorithm()]
        for a in self.alglist:
            a.initAlgorithm()
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return "Meff"
        
    def name(self):
        return "Meff"
        
    def longName(self):
        return self.name()
        
    def loadAlgorithms(self):
        for a in self.alglist:
            self.addAlgorithm(a)


class LanduseAlgorithm(QgsProcessingAlgorithm):

    INPUT = "INPUT"
    SELECT_EXPR = "SELECT_EXPR"
    OUTPUT = "OUTPUT"

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return LanduseAlgorithm()
        
    def name(self):
        return "landuseDissolve"
        
    def displayName(self):
        return self.tr("Landuse Dissolve")
        
    def group(self):
        return self.tr("Meff")
        
    def groupId(self):
        return "meff"
        
    def shortHelpString(self):
        return self.tr("TODO")

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr("Input layer"),
                [QgsProcessing.TypeVectorAnyGeometry]))
        self.addParameter(
            QgsProcessingParameterExpression(
                self.SELECT_EXPR,
                self.tr("Selection expression"),
                "",
                self.INPUT))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        feedback.pushInfo("begin")
        feedback.pushInfo("source 1 = " + str(parameters[self.INPUT]))
        #source = self.parameterAsSource(parameters,self.INPUT,context)
        source = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushInfo("source = " + str(source))
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        feedback.pushInfo("source ok")
        expr = self.parameterAsExpression(parameters,self.SELECT_EXPR,context)
        #output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        #output = self.parameterAsVectorLayer(parameters,self.OUTPUT,context)
        (sink, sink_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            source.fields(),
            source.wkbType(),
            source.sourceCrs())
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        select_layer = QgsProcessingUtils.generateTempFilename("select.gpkg")
        feedback.pushInfo("select_layer = " + str(select_layer))
        selected = qgsTreatments.extractByExpression(source,expr,'memory:')
        feedback.pushInfo("selected = " + str(selected))
        #selected = qgsTreatments.extractByExpression(source,expr,'memory:')
        selected = qgsTreatments.extractByExpression(source,expr,'memory:')
        dissolved = qgsTreatments.dissolveLayer(source,'memory:',context=context,feedback=feedback)
        #qgsUtils.loadLayer(dissolved,loadProject=True)
        feedback.pushInfo("end")
        return {self.OUTPUT : dissolved}
        
        
class ApplyFragmentationAlgorithm(QgsProcessingAlgorithm):

    LANDUSE = "LANDUSE"
    FRAGMENTATION = "FRAGMENTATION"
    OUTPUT = "OUTPUT"

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return ApplyFragmentationAlgorithm()
        
    def name(self):
        return "applyFragm"
        
    def displayName(self):
        return self.tr("Apply Fragmentation")
        
    def group(self):
        return self.tr("Meff")
        
    def groupId(self):
        return "meff"
        
    def shortHelpString(self):
        return self.tr("This algorithm cuts a land use layer with fragmentation data")

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LANDUSE,
                self.tr("Land use layer"),
                [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.FRAGMENTATION,
                self.tr("Fragmentation layers"),
                QgsProcessing.TypeVectorPolygon))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        feedback.pushInfo("begin")
        # Parameters
        feedback.pushInfo("paramters = " + str(parameters))
        landuse = self.parameterAsSource(parameters,self.LANDUSE,context)
        feedback.pushInfo("landuse = " + str(landuse))
        feedback.pushInfo("landuse type = " + str(type(landuse)))
        if landuse is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LANDUSE))
        fragm_layers = self.parameterAsLayerList(parameters,self.FRAGMENTATION,context)
        #output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        (sink, sink_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            landuse.fields(),
            landuse.wkbType(),
            landuse.sourceCrs())
        feedback.pushInfo("sink = " + str(sink))
        feedback.pushInfo("sink_id = " + str(sink_id))
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        # Merge fragmentation layers
        fragm_layer = qgsTreatments.mergeVectorLayers(fragm_layers,params.params.crs,'memory:')
        feedback.pushDebugInfo("fragm_layer = " + str(fragm_layer))
        #utils.debug("fragm_layer = " + str(fragm_layer))
        if fragm_layer is None:
            raise QgsProcessingException("Fragmentation layers merge failed")
        # Apply difference
        diff_layer = qgsTreatments.applyDifference(landuse,fragm_layer,'memory:')
        if fragm_layer is None:
            raise QgsProcessingException("Difference landuse/fragmentation failed")
        # Multi to single part
        singleGeomLayer = qgsTreatments.multiToSingleGeom(landuseFragmPath,sink_id)
        if fragm_layer is None:
            raise QgsProcessingException("Multi to single part failed")
        feedback.pushInfo("end")
        return {self.OUTPUT : fragm_layer}
        