# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MeffDialog
                                 A QGIS plugin
 This plugin computes mesh effective size
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-11-05
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os.path

from qgis.core import QgsProject, QgsMapLayerProxyModel
from processing import QgsProcessingUtils

from .shared import utils, abstract_model, qgsUtils, qgsTreatments
from . import params, landuse

fragm_fields = ["in_layer","expr","buffer","name"]

fragmModel = None

class FragmItem(abstract_model.DictItem):

    def __init__(self,in_layer,expr,buffer,name):
        dict = {"in_layer" : in_layer,
                "expr" : expr,
                "buffer" : buffer,
                "name" : name}
        super().__init__(dict)
        self.selectionLayer = None
        self.bufferLayer = None
        
    def applyItem(self):
        pass
        
    def equals(self,other):
        return (self.dict["name"] == other.dict["name"])
        
    def getSelectionLayer(self):
        if not self.selectionLayer:
            name = self.dict["name"]
            self.selectionLayer = QgsProcessingUtils.generateTempFilename(name + ".gpkg")
        return self.selectionLayer
       
    def getBufferLayer(self):
        if not self.bufferLayer:
            name = self.dict["name"]
            self.bufferLayer = QgsProcessingUtils.generateTempFilename(name + "_buf.gpkg")
        return self.bufferLayer
        
    def instantiateSelectionLayer(self):
        out_path = self.getSelectionLayer()
        qgsUtils.removeVectorLayer(out_path)
        in_layer_path = self.dict["in_layer"]
        in_layer = qgsUtils.loadVectorLayer(in_layer_path)
        selection_layer = qgsUtils.createLayerFromExisting(in_layer,self.dict["name"])
        return selection_layer
        
class FragmModel(abstract_model.DictModel):
    
    def __init__(self):
        self.parser_name = "FragmModel"
        super().__init__(self,fragm_fields)
        
    def mkItemFromDict(self,dict):
        item = FragmItem(dict["in_layer"],dict["expr"],dict["buffer"],dict["name"])
        return item
        
    def getFragmLayer(self):
        return QgsProcessingUtils.generateTempFilename("fragm.gpkg")
        
    def getLanduseFragmLayer(self):
        return params.mkOutputFile("landuseFragm.gpkg")
        
    def getFinalLayer(self):
        return params.mkOutputFile("landuseFragmSingleGeom.gpkg")
        
    def applyItems(self,indexes):
        for item in self.items:
            in_layer_path = params.getOrigPath(item.dict["in_layer"])
            in_layer = qgsUtils.loadVectorLayer(in_layer_path)
            name = item.dict["name"]
            selectionPath = item.getSelectionLayer()
            qgsTreatments.selectGeomByExpression(in_layer,item.dict["expr"],selectionPath,name)
            #selectionLayer = qgsTreatments.extractByExpression(in_layer_path,item.dict["expr"],selectionPath)
            #utils.debug("selectionNLayer = " + str(selectionLayer))
            qgsUtils.loadVectorLayer(selectionPath,loadProject=True)
            bufferPath = item.getBufferLayer()
            utils.debug("bufferPath = " + str(bufferPath))
            bufferLayer = qgsTreatments.applyBufferFromExpr(selectionPath,item.dict["buffer"],bufferPath)
            qgsUtils.loadVectorLayer(bufferLayer,loadProject=True)
        # Fragmentation layers merge
        buf_layers = [item.getBufferLayer() for item in self.items]
        fragmPath = self.getFragmLayer()
        qgsUtils.removeVectorLayer(fragmPath)
        fragm_layer = qgsTreatments.mergeVectorLayers(buf_layers,params.params.crs,'memory:')
        utils.debug("fragm_layer : " + str(fragm_layer))
        #qgsUtils.writeVectorLayer(fragm_layer,fragmPath)
        #qgsUtils.loadVectorLayer(fragmPath,loadProject=True)
        #qgsUtils.loadVectorLayer(fragmPath,loadProject=True)
        # Landuse /fragm difference
        landuseLayer = landuse.landuseModel.getDissolveLayer()
        landuseFragmPath = self.getLanduseFragmLayer()
        qgsUtils.removeVectorLayer(landuseFragmPath)
        qgsTreatments.applyDifference(landuseLayer,fragm_layer,landuseFragmPath)
        qgsUtils.loadVectorLayer(landuseFragmPath,loadProject=True)
        # Multi to single geom
        singleGeomPath = self.getFinalLayer()
        singleGeomLayer = qgsTreatments.multiToSingleGeom(landuseFragmPath,'memory:')
        qgsUtils.normFids(singleGeomLayer)
        qgsUtils.writeVectorLayer(singleGeomLayer,singleGeomPath)
        #QgsProject.instance().addMapLayer(singleGeomLayer)
        qgsUtils.loadVectorLayer(singleGeomPath,loadProject=True)
            
    def fromXMLRoot(self,root):
        utils.debug("fromXML")
        for item in root:
            utils.debug(str(item))
            dict = item.attrib
            fragmItem = self.mkItemFromDict(dict)
            self.addItem(fragmItem)
        self.layoutChanged.emit()
            
        
        
class FragmConnector(abstract_model.AbstractConnector):

    def __init__(self,dlg):
        self.parser_name = "FragmConnector"
        self.dlg = dlg
        fragmModel = FragmModel()
        self.onlySelection = False
        super().__init__(fragmModel,self.dlg.fragmView,
                        self.dlg.fragmAdd,self.dlg.fragmRemove,
                        self.dlg.fragmRun,self.dlg.fragmRunSelectionMode)

    def initGui(self):
        self.dlg.fragmInLayerCombo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        
    def connectComponents(self):
        super().connectComponents()
        self.dlg.fragmInLayer.fileChanged.connect(self.setInLayer)
        self.dlg.fragmInLayerCombo.layerChanged.connect(self.setInLayerFromCombo)
        
    def setInLayerFromCombo(self,layer):
        self.dlg.fragmExpr.setLayer(layer)
        self.dlg.fragmBuffer.setLayer(layer)
    
    def setInLayer(self,path):
        utils.debug("setInLayer " + str(path))
        layer = qgsUtils.loadVectorLayer(path,loadProject=True)
        utils.debug("layer = " + str(layer))
        self.dlg.fragmInLayerCombo.setLayer(layer)
        #self.setInLayerFromCombo(layer)
        
    def mkItem(self):
        in_layer = self.dlg.fragmInLayerCombo.currentLayer()
        if not in_layer:
            utils.user_error("No layer selected")
        in_layer_path = params.normalizePath(qgsUtils.pathOfLayer(in_layer))
        expr = self.dlg.fragmExpr.expression()
        buffer = self.dlg.fragmBuffer.expression()
        if not buffer:
            utils.user_error("Empty buffer")
        name = self.dlg.fragmName.text()
        if not name:
            utils.user_error("Empty name")
        item = FragmItem(in_layer_path,expr,buffer,name)
        return item
        
        