# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MeffDialog
                                 A QGIS plugin
 This plugin computes mesh effective size
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-11-05
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsProject, QgsMapLayerProxyModel
from processing import QgsProcessingUtils

from .shared import utils, abstract_model, qgsUtils, qgsTreatments
from . import params, landuse

fragm_fields = ["in_layer","expr","buffer","name"]

class FragmItem(abstract_model.DictItem):

    def __init__(self,in_layer,expr,buffer,name):
        dict = {"in_layer" : in_layer,
                "expr" : expr,
                "buffer" : buffer,
                "name" : name}
        super().__init__(dict)
        
        
    def applyItem(self):
        pass
        
    def equals(self,other):
        return (self.dict["name"] == other.dict["name"])
        
class FragmModel(abstract_model.DictModel):
    
    def __init__(self):
        self.parser_name = "FragmModel"
        super().__init__(self,fragm_fields)
        
    def mkItemFromDict(self,dict):
        item = FragmItem(dict["in_layer"],dict["expr"],dict["buffer"],dict["name"])
        return item
        
    def applyItems(self,indexes):
        landuseFragmPath = params.mkOutputFile("landuseFragm.gpkg")
        qgsUtils.removeVectorFile(landuseFragmPath)
        for item in self.items:
            in_layer_path = params.getOrigPath(item.dict["in_layer"])
            name = item.dict["name"]
            #qgsTreatments.selectByExpression(in_layer_path,item.dict["expr"])
            selectionPath = QgsProcessingUtils.generateTempFilename(name)
            utils.debug(selectionPath)
            #selectionLayer = qgsTreatments.saveSelectedAttributes(in_layer_path,selectionPath)
            selectionLayer = qgsTreatments.extractByExpression(in_layer_path,item.dict["expr"],selectionPath)
            utils.debug("selectionNLayer = " + str(selectionLayer))
            qgsUtils.loadVectorLayer(selectionLayer,loadProject=True)
            bufferPath = QgsProcessingUtils.generateTempFilename(name + "_buf")
            bufferLayer = qgsTreatments.applyBufferFromExpr(selectionLayer,item.dict["buffer"],bufferPath)
            qgsUtils.loadVectorLayer(bufferLayer,loadProject=True)
            if os.path.isfile(landuseFragmPath):
                landuseDiffPath = landuseFragmPath
            else:
                landuseDiffPath = landuse.landuseModel.landuseLayer
            if not landuseDiffPath:
                assert(False)
            diffPath = QgsProcessingUtils.generateTempFilename(name + "_diff")
            diffLayer = qgsTreatments.applyDifference()
            
    def fromXMLRoot(self,root):
        utils.debug("fromXML")
        for item in root:
            utils.debug(str(item))
            dict = item.attrib
            fragmItem = self.mkItemFromDict(dict)
            self.addItem(fragmItem)
        self.layoutChanged.emit()
            
        
        
class FragmConnector(abstract_model.AbstractConnector):

    def __init__(self,dlg):
        self.parser_name = "FragmConnector"
        self.dlg = dlg
        fragmModel = FragmModel()
        self.onlySelection = False
        super().__init__(fragmModel,self.dlg.fragmView,
                        self.dlg.fragmAdd,self.dlg.fragmRemove,
                        self.dlg.fragmRun,self.dlg.fragmRunSelectionMode)

    def initGui(self):
        self.dlg.fragmInLayerCombo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        
    def connectComponents(self):
        super().connectComponents()
        self.dlg.fragmInLayer.fileChanged.connect(self.setInLayer)
        self.dlg.fragmInLayerCombo.layerChanged.connect(self.setInLayerFromCombo)
        
    def setInLayerFromCombo(self,layer):
        self.dlg.fragmExpr.setLayer(layer)
        self.dlg.fragmBuffer.setLayer(layer)
    
    def setInLayer(self,path):
        utils.debug("setInLayer " + str(path))
        layer = qgsUtils.loadVectorLayer(path,loadProject=True)
        utils.debug("layer = " + str(layer))
        self.dlg.fragmInLayerCombo.setLayer(layer)
        #self.setInLayerFromCombo(layer)
        
    def mkItem(self):
        in_layer = self.dlg.fragmInLayerCombo.currentLayer()
        if not in_layer:
            utils.user_error("No layer selected")
        in_layer_path = params.normalizePath(qgsUtils.pathOfLayer(in_layer))
        expr = self.dlg.fragmExpr.expression()
        buffer = self.dlg.fragmBuffer.expression()
        if not buffer:
            utils.user_error("Empty buffer")
        name = self.dlg.fragmName.text()
        if not name:
            utils.user_error("Empty name")
        item = FragmItem(in_layer_path,expr,buffer,name)
        return item
        
        