# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FragScape
                                 A QGIS plugin
 This plugin computes mesh effective size
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-11-05
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os.path
import time

from qgis.core import QgsProject, QgsMapLayerProxyModel, QgsVectorLayer, QgsProcessingFeedback, QgsProcessingMultiStepFeedback
import processing
from processing import QgsProcessingUtils

from ..qgis_lib_mc import utils, abstract_model, qgsUtils, qgsTreatments, feedbacks
from ..algs import FragScape_algs
from . import params, landuse



fragmModel = None

class FragmItem(abstract_model.DictItem):

    INPUT = FragScape_algs.PrepareFragmentationAlgorithm.INPUT
    SELECT_EXPR = FragScape_algs.PrepareFragmentationAlgorithm.SELECT_EXPR
    BUFFER = FragScape_algs.PrepareFragmentationAlgorithm.BUFFER
    NAME = "NAME"
    FRAGM = "FRAGM"

    FIELDS = [INPUT,SELECT_EXPR,BUFFER,NAME,FRAGM]


    def __init__(self,dict):
        if self.FRAGM not in dict:
            dict[self.FRAGM] = True
        super().__init__(dict,fields=self.FIELDS)
        self.selectionLayer = None
        self.bufferLayer = None
        
    def applyItem(self):
        pass
        
    def equals(self,other):
        return (self.dict[self.NAME] == other.dict[self.NAME])
        
    def getOutputLayer(self):
        name = self.dict[self.NAME]
        self.outputLayer = params.mkTmpLayerPath(name + ".gpkg")
        return self.outputLayer
        
    def getOutputRLayer(self):
        name = self.dict[self.NAME]
        self.outputLayer = params.mkTmpLayerPath(name + ".tif")
        return self.outputLayer
        
    def getSelectionLayer(self):
        if not self.selectionLayer:
            name = self.dict[self.NAME]
            self.selectionLayer = params.mkTmpLayerPath(name + ".gpkg")
            #self.selectionLayer = QgsProcessingUtils.generateTempFilename(name + ".gpkg")
        return self.selectionLayer
       
    def getBufferLayer(self):
        if not self.bufferLayer:
            name = self.dict[self.NAME]
            self.bufferLayer = params.mkTmpLayerPath(name + "_buf.gpkg")
            #self.bufferLayer = QgsProcessingUtils.generateTempFilename(name + "_buf.gpkg")
        return self.bufferLayer
        
    # def prepareVector(self,context,feedback):
        # in_layer_path = item.dict[self.INPUT]
        # in_layer_abs_path = self.fsModel.getOrigPath(in_layer_path)
        # clip_layer_path = item.dict[self.CLIP_LAYER]
        # if clip_layer_path:
            # clip_layer_abs_path = self.fsModel.getOrigPath(clip_layer_path)
        # else:
            # clip_layer_abs_path = None
        # select_expr = item.dict[self.SELECT_EXPR]
        # buffer_expr = item.dict[self.PREPARE_BUFFER]
        # utils.debug("select_expr : " + str(select_expr))
        # utils.debug("buffer_expr : " + str(buffer_expr))
        # outPath = item.getOutputLayer()
        # name = item.dict[self.PREPARE_NAME]
        # parameters = { self.PREPARE_INPUT : in_layer_abs_path,
                       # self.PREPARE_CLIP_LAYER : clip_layer_abs_path,
                       # self.PREPARE_SELECT_EXPR : select_expr,
                       # self.PREPARE_BUFFER : buffer_expr,
                       # self.PREPARE_NAME : item.dict[self.PREPARE_NAME],
                       # self.PREPARE_OUTPUT : outPath }
        # prepared = qgsTreatments.applyProcessingAlg(
            # "FragScape","prepareFragm",parameters,
            # context=context,feedback=step_feedback)
            

        
    # def instantiateSelectionLayer(self):
        # out_path = self.getSelectionLayer()
        # qgsUtils.removeVectorLayer(out_path)
        # in_layer_path = self.dict["in_layer"]
        # in_layer = qgsUtils.loadVectorLayer(in_layer_path)
        # selection_layer = qgsUtils.createLayerFromExisting(in_layer,self.dict["name"])
        # return selection_layer
        
class FragmModel(abstract_model.DictModel):

    PREPARE_INPUT = FragmItem.INPUT
    PREPARE_SELECT_EXPR = FragmItem.SELECT_EXPR
    PREPARE_BUFFER = FragmItem.BUFFER
    PREPARE_NAME = FragmItem.NAME
    PREPARE_OUTPUT = FragScape_algs.PrepareFragmentationAlgorithm.OUTPUT
    
    FIELDS = FragmItem.FIELDS
    
    APPLY_LANDUSE = FragScape_algs.ApplyFragmentationAlgorithm.LANDUSE
    APPLY_FRAGMENTATION = FragScape_algs.ApplyFragmentationAlgorithm.FRAGMENTATION
    APPLY_CRS = FragScape_algs.ApplyFragmentationAlgorithm.CRS
    APPLY_OUTPUT = FragScape_algs.ApplyFragmentationAlgorithm.OUTPUT
    
    def __init__(self,fsModel):
        self.parser_name = "FragmModel"
        self.fsModel = fsModel
        super().__init__(self,self.FIELDS)
        
    def mkItemFromDict(self,dict):
        if "in_layer" in dict:
            new_dict = { FragmItem.INPUT : dict["in_layer"],
                         FragmItem.SELECT_EXPR : dict["expr"],
                         FragmItem.BUFFER : dict["buffer"],
                         FragmItem.NAME : dict["name"],
                         FragmItem.FRAGM : True
                         }
            return FragmItem(new_dict)
        else:
            if FragmItem.FRAGM in dict:
                dict[FragmItem.FRAGM]  = bool(dict[FragmItem.FRAGM])
            else:
                dict[FragmItem.FRAGM]  = True
            return FragmItem(dict)
        
    # def getFragmLayer(self):
        # return params.mkTmpLayerPath("fragm.gpkg")
        
    # def getBuffersMergedLayer(self):
        # return params.mkTmpLayerPath("fragmBuffersMerged.shp")
        
    # def getLanduseFragmLayer(self):
        # return params.mkTmpLayerPath("landuseFragm.gpkg")
        
    def getSingleGeomLayer(self):
        return self.fsModel.mkOutputFile("landuseFragmSingleGeom.gpkg")
    def getSingleGeomLayerTmp(self):
        return QgsProcessingUtils.generateTempFilename("landuseFragmSingleGeom_tmp.gpkg")
        
    def getMergedLayer(self):
        return self.fsModel.mkOutputFile("landuseFragm.tif")
    def getmergeLayerTmp(self):
        return QgsProcessingUtils.generateTempFilename("landuseFragm_tmp.tif")
        
    def getFinalLayer(self):
        self.getFinalLayers()[1]
            
    def getFinalLayers(self):
        extentLayer = self.fsModel.paramsModel.getExtentLayer()
        if self.fsModel.modeIsVector():
            final_path = self.getSingleGeomLayer()
            if extentLayer:
                tmp_path = self.getSingleGeomLayerTmp()
            else:
                tmp_path = final_path
        else:
            final_path = self.getMergedLayer()
            if extentLayer:
                tmp_path = self.getmergeLayerTmp()
            else:
                tmp_path = final_path
        return (tmp_path, final_path)
            
    def prepareItem(self,item,context,feedback):
        self.fsModel.checkWorkspaceInit()
        # self.fsModel.checkExtentInit()
        input_rel = item.dict[FragmItem.INPUT]
        feedback.pushDebugInfo("input_rel = " + str(input_rel))
        input = self.fsModel.getOrigPath(input_rel)
        feedback.pushDebugInfo("input = " + str(input))
        input_layer, input_type = qgsUtils.loadLayerGetType(input)
        input_vector = input_type == 'Vector'
        select_expr = item.dict[FragmItem.SELECT_EXPR]
        buffer_expr = item.dict[FragmItem.BUFFER]
        name = item.dict[FragmItem.NAME]
        is_fragm = item.dict[FragmItem.FRAGM]
        burn_val = (1 if is_fragm else 0)
        vector_mode = self.fsModel.modeIsVector()
        outPath = item.getOutputLayer()
        feedback.pushDebugInfo("outPath = " + str(outPath))
        outRPath = item.getOutputRLayer()
        feedback.pushDebugInfo("outRPath = " + str(outRPath))
        # Processing
        # clipped = self.fsModel.paramsModel.clipByExtent(input,name=name,context=context,feedback=feedback)
        clipped = self.fsModel.paramsModel.clipByExtent(input,
            name=name,context=context,feedback=feedback)
        feedback.pushDebugInfo("clipped = " + str(clipped))
        if input_vector:
            parameters = { self.PREPARE_INPUT : clipped,
                           self.PREPARE_SELECT_EXPR : select_expr,
                           self.PREPARE_BUFFER : buffer_expr,
                           self.PREPARE_NAME : name,
                           self.PREPARE_OUTPUT : outPath }
            prepared = qgsTreatments.applyProcessingAlg(
                "FragScape","prepareFragm",parameters,
                context=context,feedback=feedback)
            if vector_mode:
                res = prepared
            else:
                self.fsModel.checkResolutionInit()
                self.fsModel.checkExtentInit()
                crs, extent, resolution = self.fsModel.getRasterParams()
                res = qgsTreatments.applyRasterization(prepared,outRPath,
                    extent,resolution,out_type=0,nodata_val=255,burn_val=burn_val,
                    all_touch=True,context=context,feedback=feedback)
        elif vector_mode:
            utils.internal_error("Not implemented yet : Raster to Vector")
        else:
            self.fsModel.checkResolutionInit()
            # normalized_path = QgsProcessingUtils.generateTempFilename(name + '_normalized.tif')
            # normalized = self.fsModel.paramsModel.normalizeRaster(input,
                # out_path=normalized_path,context=context,feedback=feedback)
            res = qgsTreatments.applyRasterCalc(clipped,outRPath,str(burn_val),
                out_type=0,context=context,feedback=feedback)
        return res
            
    def applyItemsWithContext(self,context,feedback,indexes=None):
        fragmMsg = "Application of fragmentation data to landuse"
        feedbacks.progressFeedback.beginSection(fragmMsg)
        prepared_layers = []
        nb_items = len(self.items)
        curr_step = 1
        step_feedback = feedbacks.ProgressMultiStepFeedback(nb_items,feedback)
        for item in self.items:
            feedback.pushDebugInfo("item = " + str(item))
            prepared = self.prepareItem(item,context,step_feedback)
            curr_step += 1
            step_feedback.setCurrentStep(curr_step)
            prepared_layers.append(prepared)
        feedback.pushDebugInfo("prepared_layers = " + str(prepared_layers))
        # MERGE
        tmp_path, res_path = self.getFinalLayers()
        feedback.pushDebugInfo("res_path = " + str(res_path))
        # qgsUtils.removeVectorLayer(res_path)
        vector_mode = self.fsModel.modeIsVector()
        landuseLayer = self.fsModel.landuseModel.getOutputLayer()
        if vector_mode:
            qgsUtils.removeVectorLayer(res_path)
            # landuseLayer = self.fsModel.landuseModel.getDissolveLayer()
            crs = self.fsModel.paramsModel.crs
            parameters = { self.APPLY_LANDUSE : landuseLayer,
                           self.APPLY_FRAGMENTATION : prepared_layers,
                           self.APPLY_CRS : crs,
                           self.APPLY_OUTPUT : tmp_path }
            res = qgsTreatments.applyProcessingAlg(
                "FragScape","applyFragm",parameters,
                context=context,feedback=feedback)
            # qgsUtils.loadVectorLayer(tmp_path,loadProject=True)
        else:
            qgsUtils.removeRaster(res_path)
            # landuseLayer = self.fsModel.landuseModel.getOutputRaster()
            prepared_layers.insert(0,landuseLayer)
            res = qgsTreatments.applyMergeRaster(prepared_layers,tmp_path,
                nodata_val=255,out_type=0,nodata_input=255,
                context=context,feedback=feedback)
            # qgsUtils.loadRasterLayer(tmp_path,loadProject=True)
        # TODO CLIP
        res = self.fsModel.paramsModel.clipByExtent(tmp_path,
            out_path=res_path,context=context,feedback=feedback)
        qgsUtils.loadLayer(res,loadProject=True)
        feedbacks.progressFeedback.endSection()
        return res
            
            
            
        # if self.fsModel.modeIsVector():
            # res = self.applyVector(context,feedback)
        # else:
            # res = self.applyRaster(context,feedback)
        # feedbacks.progressFeedback.endSection()
        # return res
            
    # def fromXMLRoot(self,root):
        # utils.debug("fromXML")
        # for item in root:
            # utils.debug(str(item))
            # dict = item.attrib
            # fragmItem = self.mkItemFromDict(dict)
            # self.addItem(fragmItem)
        # self.layoutChanged.emit()
            
        
        
class FragmConnector(abstract_model.AbstractConnector):

    def __init__(self,dlg,fragmModel):
        self.parser_name = "FragmConnector"
        self.dlg = dlg
        self.onlySelection = False
        # self.fragmFlag = True
        self.fragmStatus = None
        self.clip_layer = None
        super().__init__(fragmModel,self.dlg.fragmView,
                        self.dlg.fragmAdd,self.dlg.fragmRemove,
                        self.dlg.fragmRun)

    def initGui(self):
        self.dlg.fragmInputLayerCombo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        
    def connectComponents(self):
        super().connectComponents()
        #self.dlg.fragmInLayer.fileChanged.connect(self.setInLayer)
        self.dlg.fragmInputLayerCombo.layerChanged.connect(self.setInLayerFromCombo)
        self.layerComboDlg = qgsUtils.LayerComboDialog(self.dlg,
                                                       self.dlg.fragmInputLayerCombo,
                                                       self.dlg.fragmInputLayer)
        # self.dlg.fragmCheckbox.stateChanged.connect(self.switchFragmFlag)
        self.dlg.fragmStatus.currentIndexChanged.connect(self.switchFragmStatus)
        self.dlg.selectionUp.clicked.connect(self.upgradeItem)
        self.dlg.selectionDown.clicked.connect(self.downgradeItem)
        
    def applyItems(self):
        self.dlg.resultsInputLayer.setLayer(None)
        # self.dlg.resultsSelection.setLayer(None)
        super().applyItems()
        tmp_path, res_path = self.model.getFinalLayers()
        res_layer = qgsUtils.loadLayer(res_path)
        self.dlg.resultsInputLayer.setLayer(res_layer)
        
    def setInLayerFromCombo(self,layer):
        self.dlg.fragmExpr.setLayer(layer)
        self.dlg.fragmBuffer.setLayer(layer)
    
    # def switchFragmFlag(self,state):
        # utils.debug("switchFragmFlag")
        # self.fragmFlag = not self.fragmFlag
        
    def switchFragmStatus(self,index):
        if index == 0:
            self.fragmStatus = None
        elif index == 1:
            self.fragmStatus = True
        elif index == 2:
            self.fragmStatus = False
        else:
            utils.debug("Unexpected fragmentation status : " + str(index))
    
    # def setInLayer(self,path):
        # utils.debug("setInLayer " + str(path))
        # layer = qgsUtils.loadVectorLayer(path,loadProject=True)
        # utils.debug("layer = " + str(layer))
        # self.dlg.fragmInputLayerCombo.setLayer(layer)
        
    def mkItem(self):
        in_layer = self.dlg.fragmInputLayerCombo.currentLayer()
        if not in_layer:
            utils.user_error("No layer selected")
        in_layer_path = self.model.fsModel.normalizePath(qgsUtils.pathOfLayer(in_layer))
        expr = self.dlg.fragmExpr.expression()
        buffer = self.dlg.fragmBuffer.expression()
        #if not buffer:
        #    utils.user_error("Empty buffer")
        name = self.dlg.fragmName.text()
        # is_fragm = self.fragmFlag
        is_fragm = self.fragmStatus
        if not name:
            utils.user_error("Empty name")
        if is_fragm is None:
            utils.user_error("No fragmentation status selected")
        dict = { FragmItem.INPUT : in_layer_path,
                 FragmItem.SELECT_EXPR : expr,
                 FragmItem.BUFFER : buffer,
                 FragmItem.NAME : name,
                 FragmItem.FRAGM : is_fragm}
        item = FragmItem(dict)
        return item
        
        