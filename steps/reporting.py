# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MeffDialog
                                 A QGIS plugin
 This plugin computes mesh effective size
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-11-05
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Mathieu Chailloux
        email                : mathieu@chailloux.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsMapLayerProxyModel, QgsField, QgsFeature, QgsProcessingFeedback, QgsVectorLayerCache
from qgis.gui import QgsFileWidget, QgsAttributeTableModel, QgsAttributeTableView, QgsAttributeTableFilterModel
from qgis.utils import iface
from PyQt5.QtCore import QVariant
from processing import QgsProcessingUtils

from ..shared import utils, abstract_model, qgsUtils, progress, qgsTreatments
from ..algs import meff_algs
from . import params, fragm

class ReportingModel(abstract_model.DictModel):

    # Configuration slots
    INPUT = "input_layer"
    SELECT_EXPR = "select_expr"
    REPORTING = "reporting_layer"
    METHOD = "method"
    OUTPUT = "output"
    
    CUT_METHOD = 0
    CBC_METHOD = 1

    def __init__(self,fsModel):
        self.parser_name = "Reporting"
        self.fsModel = fsModel
        self.input_layer = None
        self.select_expr = None
        self.reporting_layer = None
        self.method = self.CUT_METHOD
        self.out_layer = None
        self.init_fields = []
        self.fields = self.init_fields
        super().__init__(self,self.fields)
        #super().__init__(self,self.fields)
                
    def getInputLayer(self):
        if not self.input_layer:
            self.input_layer = self.fsModel.fragmModel.getFinalLayer()
        return self.input_layer
                
    def setOutLayer(self,layer):
        self.out_layer = layer
        
    def getOutLayer(self):
        if self.out_layer:
            return self.fsModel.getOrigPath(self.out_layer)
        else:
            return QgsProcessingUtils.generateTempFilename("reportingResults.gpkg")
        
    def mkIntersectionLayer(self):
        pass
        
    def getIntersectionLayerPath(self):
        return self.fsModel.mkOutputFile("reportingIntersection.gpkg")
        
    def getReportingResultsLayerPath(self):
        return self.fsModel.mkOutputFile("reportingResults.gpkg")
                
    def runReportingWithContext(self,context,feedback):
        reportingMsg = "Reporting layer computation"
        progress.progressFeedback.beginSection(reportingMsg)
        input_layer = self.getInputLayer()
        if self.select_expr:
            selected = qgsTreatments.extractByExpression(
                input_layer,self.select_expr,'memory:',
                context=context,feedback=feedback)
        else:
            selected = input_layer
        results_path = self.getOutLayer()
        qgsUtils.removeVectorLayer(results_path)
        if self.method == self.CUT_METHOD:
            cut_mode = True
        elif self.method == self.CBC_METHOD:
            cut_mode = False
        else:
            utils.internal_error("Unepexted method : " + str(self.method))
        parameters = { meff_algs.EffectiveMeshSizeAlgorithm.INPUT : selected,
                       #meff_algs.EffectiveMeshSizeAlgorithm.REPORTING : qgsUtils.pathOfLayer(self.layer),
                       meff_algs.EffectiveMeshSizeAlgorithm.REPORTING : self.reporting_layer,
                       meff_algs.EffectiveMeshSizeAlgorithm.CUT_MODE : cut_mode,
                       meff_algs.EffectiveMeshSizeAlgorithm.OUTPUT : results_path }
        res = qgsTreatments.applyProcessingAlg(
            "Meff","effectiveMeshSize",parameters,
            context=context,feedback=feedback)
        qgsUtils.loadVectorLayer(res,loadProject=True)
        progress.progressFeedback.endSection()
        return results_path
                
    def toXML(self,indent=" "):
        if not self.reporting_layer:
            utils.warn("No reporting layer selected")
            return ""
        #layerRelPath = self.fsModel.normalizePath(qgsUtils.pathOfLayer(self.layer))
        modelParams = {}
        # if self.input_layer:
            # pass
        if self.select_expr:
            modelParams[self.SELECT_EXPR] = self.select_expr
        if self.method:
            modelParams[self.METHOD] = self.method
        if self.reporting_layer:
            layerRelPath = self.fsModel.normalizePath(self.reporting_layer)
            modelParams[self.REPORTING] = layerRelPath
        if self.out_layer:
            modelParams[self.OUTPUT] = self.fsModel.normalizePath(self.out_layer)
        xmlStr = super().toXML(indent,modelParams)
        return xmlStr
        
    def fromXMLAttribs(self,attribs):
        if self.SELECT_EXPR in attribs:
            self.select_expr = attribs[self.SELECT_EXPR]
        if self.REPORTING in attribs:
            self.reporting_layer = self.fsModel.getOrigPath(attribs[self.REPORTING])
        if self.METHOD in attribs:
            self.method = int(attribs[self.METHOD])
        if self.OUTPUT in attribs:
            self.setOutLayer(attribs[self.OUTPUT])
        
    def fromXMLRoot(self,root):
        self.fromXMLAttribs(root.attrib)
        
class ReportingConnector(abstract_model.AbstractConnector):

    
    def __init__(self,dlg,reportingModel):
        self.dlg = dlg
        self.parser_name = "Reporting"
        #self.model = reportingModel
        #reportingModel = ReportingModel()
        super().__init__(reportingModel,self.dlg.resultsView)
        
    def initGui(self):
        self.dlg.resultsInputLayer.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.dlg.resultsReportingLayer.setStorageMode(QgsFileWidget.GetFile)
        self.dlg.resultsReportingLayer.setFilter(qgsUtils.getVectorFilters())
        self.dlg.resultsOutLayer.setStorageMode(QgsFileWidget.SaveFile)
        self.dlg.resultsOutLayer.setFilter(qgsUtils.getVectorFilters())
        #self.attrView = QgsAttributeTableView(self.dlg)
        #self.dlg.gridLayout_9.removeWidget(self.dlg.resultsView)
       # self.dlg.gridLayout_9.addWidget(self.attrView)
        #self.dlg.resultsView.hide()
        #self.dlg.gridLayout_9.removeWidget(self.dlg.resultsView)
        
    def connectComponents(self):
        super().connectComponents()
        #self.dlg.reportingLayerCombo.layerChanged.connect(self.setLayer)
        self.dlg.resultsReportingLayer.fileChanged.connect(self.loadLayer)
        self.dlg.resultsCutMode.currentIndexChanged.connect(self.setMethod)
        self.dlg.resultsOutLayer.fileChanged.connect(self.model.setOutLayer)
        self.dlg.resultsRun.clicked.connect(self.runReporting)
        
    def runReporting(self):
        out_layer = self.model.runReportingWithContext(self.dlg.context,self.dlg.feedback)
        self.loaded_layer = qgsUtils.loadVectorLayer(out_layer)
        self.layer_cache = QgsVectorLayerCache(self.loaded_layer,24)
        self.attribute_model = QgsAttributeTableModel(self.layer_cache)
        self.attribute_model.loadLayer()
        self.dlg.resultsView.setModel(self.attribute_model)
        #self.dlg.resultsView.show()
        
    # def setLayer(self,layer):
        # utils.debug("setLayer " + str(layer.type))
        # self.dlg.reportingLayerCombo.setLayer(layer)
        # self.model.reporting_layer = qgsUtils.pathOfLayer(layer)
    
    def setMethod(self,idx):
        if idx == 0:
            self.model.method = ReportingModel.CUT_METHOD
        elif idx == 1:
            self.model.method = ReportingModel.CBC_METHOD
        else:
            utils.internal_error("Unexpected index for reporting method : " + str(idx))
    
    def loadLayer(self,path):
        utils.debug("loadLayer")
        loaded_layer = qgsUtils.loadVectorLayer(path,loadProject=True)
        #self.dlg.reportingLayerCombo.setLayer(loaded_layer)
        self.dlg.resultsSelection.setLayer(loaded_layer)
        self.model.reporting_layer = path
        #self.setLayer(loaded_layer)
        
    def updateUI(self):
        # if self.model.input_layer:
            # abs_input_layer = qgsUtils.loadVectorLayer(self.model.input_layer,loadProject=True)
            # self.dlg.resultsReportingLayer.setLayer(abs_input_layer)
        if self.model.select_expr:
            self.dlg.resultsSelection.setExpression(self.model.select_expr)
        if self.model.reporting_layer:
            #qgsUtils.loadVectorLayer(self.model.reporting_layer,loadProject=True)
            self.dlg.resultsReportingLayer.setFilePath(self.model.reporting_layer)
        if self.model.method:
            self.dlg.resultsCutMode.setCurrentIndex(int(self.model.method))
        if self.model.out_layer:
            self.dlg.resultsOutLayer.setFilePath(self.model.out_layer)

    def fromXMLRoot(self,root):
        self.model.fromXMLRoot(root)
        self.updateUI()
        
    def toXML(self,indent=" "):
        return self.model.toXML()
        