# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Meff
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsMapLayerProxyModel, QgsProcessing, QgsProcessingAlgorithm, QgsProcessingException, QgsProcessingParameterFeatureSource, QgsProcessingParameterExpression, QgsProcessingParameterFeatureSink
# from PyQt5 import QtGui, QtCore, QtWidgets
# from PyQt5.QtCore import QCoreApplication
from ..shared import utils, abstract_model, qgsUtils, progress, qgsTreatments
from ..algs import meff_algs 
from . import params

landuseModel = None

        
class LanduseFieldItem(abstract_model.DictItem):

    VALUE_FIELD = "value"
    TO_SELECT_FIELD = "toSelect"

    def __init__(self,val,isNatural=False):
        dict = {self.VALUE_FIELD : val, self.TO_SELECT_FIELD : isNatural}
        super().__init__(dict)
        
        
class LanduseModel(abstract_model.DictModel):

    # INPUT = meff_algs.PrepareLanduseAlgorithm.INPUT
    # CLIP_LAYER = meff_algs.PrepareLanduseAlgorithm.CLIP_LAYER
    # SELECT_EXPR = meff_algs.PrepareLanduseAlgorithm.SELECT_EXPR
    # OUTPUT = meff_algs.PrepareLanduseAlgorithm.OUTPUT
    INPUT = "in_layer"
    ALG_INPUT = meff_algs.PrepareLanduseAlgorithm.INPUT
    ALG_CLIP_LAYER = meff_algs.PrepareLanduseAlgorithm.CLIP_LAYER
    ALG_SELECT_EXPR = meff_algs.PrepareLanduseAlgorithm.SELECT_EXPR
    ALG_OUTPUT = meff_algs.PrepareLanduseAlgorithm.OUTPUT
    
    SELECT_FIELD = "field"
    FIELDS = [LanduseFieldItem.VALUE_FIELD,LanduseFieldItem.TO_SELECT_FIELD]

    def __init__(self,fragScapeModel):
        self.parser_name = "Landuse"
        self.fsModel = fragScapeModel
        self.landuseLayer = None
        self.landuseField = None
        self.dataClipFlag = True
        super().__init__(self,self.FIELDS)
                        
    def mkItemFromDict(self,dict):
        utils.debug("dict : " + str(dict))
        v = dict[LanduseFieldItem.VALUE_FIELD]
        i = (dict[LanduseFieldItem.TO_SELECT_FIELD] == "True")
        return LanduseFieldItem(v,i)
        
    def checkLayerSelected(self):
        if not self.landuseLayer:
            utils.user_error("No layer selected")
            
    def checkFieldSelected(self):
        if not self.landuseField:
            utils.user_error("No field selected")
            
    def getClipLayer(self):
        return self.fsModel.mkOutputFile("landuseClip.gpkg")
            
    def getSelectionLayer(self):
        return self.fsModel.mkOutputFile("landuseSelection.gpkg")
            
    def getDissolveLayer(self):
        return self.fsModel.mkOutputFile("landuseSelectionDissolve.gpkg")
        
    def switchDataClipFlag(self,state):
        utils.debug("switchDataClipFlag")
        self.dataClipFlag = not self.dataClipFlag

    def mkSelectionExpr(self):
        expr = ""
        for item in self.items:
            if item.dict[LanduseFieldItem.TO_SELECT_FIELD]:
                if expr != "":
                    expr += " + "
                field_val = item.dict[LanduseFieldItem.VALUE_FIELD].replace("'","''")
                expr += "(\"" + self.landuseField + "\" = '" + field_val + "')"
        utils.debug("selectionExpr = " + expr)
        return expr
        
    # def applyItemsOld(self):
        # progress.progressFeedback.beginSection("Landuse classification")
        # params.checkWorkspaceInit()
        # self.checkLayerSelected()
        # self.checkFieldSelected()
        # in_layer = qgsUtils.pathOfLayer(self.landuseLayer)
        # territory_layer = params.getTerritoryLayer()
        # expr = self.mkSelectionExpr()
        # if not expr:
            # utils.user_error("No expression selected : TODO select everything")
        # selectionResLayer = self.getSelectionLayer()
        # dissolveLayer = self.getDissolveLayer()
        # qgsUtils.removeVectorLayer(selectionResLayer)
        # qgsUtils.removeVectorLayer(dissolveLayer)
        # if params.getDataClipFlag():
            # utils.debug("dataClipFlag activated")
            # clip_layer = self.getClipLayer()
            # qgsUtils.removeVectorLayer(clip_layer)
            # qgsTreatments.applyVectorClip(in_layer,territory_layer,clip_layer)
            # extractSourceLayer = clip_layer
        # else:
            # extractSourceLayer = in_layer
        # qgsTreatments.extractByExpression(extractSourceLayer,expr,selectionResLayer)
        # dissolved = qgsTreatments.dissolveLayer(selectionResLayer,dissolveLayer)
        # qgsUtils.loadLayer(dissolved,loadProject=True)
        # progress.progressFeedback.endSection()
        
    def applyItemsWithContext(self,context,feedback):
        progress.progressFeedback.beginSection("Landuse classification")
        self.fsModel.checkWorkspaceInit()
        self.checkLayerSelected()
        self.checkFieldSelected()
        #in_layer = qgsUtils.pathOfLayer(self.landuseLayer)
        clip_layer = self.fsModel.paramsModel.getTerritoryLayer()
        expr = self.mkSelectionExpr()
        if not expr:
            utils.user_error("No expression selected : TODO select everything")
        dissolveLayer = self.getDissolveLayer()
        qgsUtils.removeVectorLayer(dissolveLayer)
        parameters = { self.ALG_INPUT : self.landuseLayer,
                       self.ALG_CLIP_LAYER : clip_layer,
                       self.ALG_SELECT_EXPR : expr,
                       self.ALG_OUTPUT : dissolveLayer }
        res = qgsTreatments.applyProcessingAlg(
            "Meff","prepareLanduse",parameters,
            context,feedback)
        qgsUtils.loadVectorLayer(dissolveLayer,loadProject=True)
        progress.progressFeedback.endSection()
        
    # def applyItems(self):
        # context = None
        # feedback  =progress.progressFeedback
        # self.applyItemsWithFB(context,feedback)
        
    def toXML(self,indent=" "):
        if not self.landuseLayer:
            utils.warn("No layer selected")
            return ""
        if not self.landuseField:
            utils.warn("No field selected")
            return ""
        #layerRelPath = self.fsModel.normalizePath(qgsUtils.pathOfLayer(self.landuseLayer))
        layerRelPath = self.fsModel.normalizePath(self.landuseLayer)
        attribs_dict = { self.INPUT : layerRelPath, self.SELECT_FIELD : self.landuseField }
        xmlStr = super().toXML(indent,attribs_dict)
        return xmlStr
        
    def fromXMLAttribs(self,attribs):
        if self.INPUT in attribs:
            abs_layer = self.fsModel.getOrigPath(attribs[self.INPUT])
            self.landuseLayer = abs_layer
        if self.SELECT_FIELD in attribs:
            self.landuseField = attribs[self.SELECT_FIELD]
        
    def fromXMLRoot(self,root):
        self.fromXMLAttribs(root.attrib)
        self.items = []
        for parsed_item in root:
            dict = parsed_item.attrib
            item = self.mkItemFromDict(dict)
            self.addItem(item)
        self.layoutChanged.emit()

        
class LanduseConnector(abstract_model.AbstractConnector):

    def __init__(self,dlg,landuseModel):
        self.dlg = dlg
        self.parser_name = "Landuse"
        self.dlg.landuseView.setItemDelegateForColumn(1,abstract_model.CheckBoxDelegate(self.dlg.landuseView))
        #landuse_model = LanduseModel()
        super().__init__(landuseModel,self.dlg.landuseView)
        
    def initGui(self):
        self.dlg.landuseLayerCombo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.dlg.landuseLayer.setFilter(qgsUtils.getVectorFilters())
        
    def connectComponents(self):
        super().connectComponents()
        self.dlg.landuseLayerCombo.layerChanged.connect(self.setLayer)
        self.dlg.landuseLayer.fileChanged.connect(self.loadLayer)
        self.dlg.landuseFieldCombo.fieldChanged.connect(self.loadField)
        self.dlg.landuseRun.clicked.connect(self.applyItems)
        self.dlg.dataClipFlag.stateChanged.connect(self.model.switchDataClipFlag)
        
    def setLayer(self,layer):
        utils.debug("setLayer " + str(layer.type))
        self.dlg.landuseFieldCombo.setLayer(layer)
        self.model.landuseLayer = layer
  
    def loadLayer(self,path):
        utils.debug("loadLayer")
        loaded_layer = qgsUtils.loadVectorLayer(path,loadProject=True)
        self.setLayer(loaded_layer)
        self.dlg.landuseLayerCombo.setLayer(loaded_layer)
        
    def loadField(self,fieldname):
        utils.debug("loadField")
        curr_layer = self.dlg.landuseLayerCombo.currentLayer()
        if not curr_layer:
            utils.internal_error("No layer selected in landuse tab")
        if fieldname == self.model.landuseField:
            return
        fieldVals = qgsUtils.getLayerFieldUniqueValues(curr_layer,fieldname)
        self.model.items = []
        for fieldVal in fieldVals:
            utils.debug("fieldVal : " + str(fieldVal))
            item = LanduseFieldItem(fieldVal,False)
            self.model.addItem(item)
        self.model.landuseField = fieldname
        self.model.layoutChanged.emit()
        
    def updateUI(self):
        utils.debug("1")
        if self.model.landuseLayer:
            utils.debug("2")
            self.loadLayer(self.model.landuseLayer)
        if self.model.landuseField:
            utils.debug("3")
            self.dlg.landuseFieldCombo.setField(self.model.landuseField)
        
    def fromXMLRoot(self,root):
        self.model.fromXMLRoot(root)
        self.updateUI()

    # def fromXMLAttribs(self,attribs):
        # attrib_fields = ["layer", "field"]
        # utils.checkFields(attrib_fields,attribs.keys())
        # abs_layer = self.model.fsModel.getOrigPath(attribs["layer"])
        # self.loadLayer(abs_layer)
        # self.dlg.landuseFieldCombo.setField(attribs["field"])
        
    # def fromXMLRoot(self,root):
        # self.fromXMLAttribs(root.attrib)
        # self.model.items = []
        # for parsed_item in root:
            # dict = parsed_item.attrib
            # item = self.model.mkItemFromDict(dict)
            # self.model.addItem(item)
        # self.model.layoutChanged.emit()
        
    def toXML(self):
        return self.model.toXML()
    